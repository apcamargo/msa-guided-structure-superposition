#!/usr/bin/env python

import logging
import os
import sys
from typing import Dict, List, Tuple

import rich_click as click
from Bio import PDB, SeqIO
from Bio.PDB.Superimposer import Superimposer
from rich.logging import RichHandler

# Configure logger
logger = logging.getLogger()


def parse_msa(msa_file: str) -> Dict[str, str]:
    """Parse MSA file and return a dictionary of sequences."""
    sequences = {}
    for record in SeqIO.parse(msa_file, "fasta"):
        sequences[record.id] = str(record.seq)
    return sequences


def get_aligned_positions(sequences: Dict[str, str]) -> List[int]:
    """Extract positions that are aligned across all sequences (no gaps in any sequence)."""
    # Find positions without gaps in any sequence
    aligned_positions = []
    seq_length = len(next(iter(sequences.values())))

    for i in range(seq_length):
        if all(seq[i] != "-" for seq in sequences.values()):
            aligned_positions.append(i)

    return aligned_positions


def map_sequence_to_structure(
    sequence: str, structure_file: str
) -> Tuple[Dict[int, int], PDB.Structure.Structure]:
    """Map sequence positions to structure residue IDs, handling gaps."""
    parser = PDB.PDBParser(QUIET=True)
    structure = parser.get_structure(structure_file, structure_file)

    # Get chain A residues (modify if using different chains)
    residues = list(structure[0]["A"].get_residues())

    # Create mapping from sequence position to structure position
    seq_to_struct = {}
    struct_pos = 0

    for seq_pos, aa in enumerate(sequence):
        if aa != "-":  # If not a gap
            if struct_pos < len(residues):
                seq_to_struct[seq_pos] = residues[struct_pos].id[1]
            struct_pos += 1

    return seq_to_struct, structure


def align_structures_by_msa(
    msa_file: str, pdb_files: Dict[str, str], output_dir: str = "aligned_pdbs"
) -> Dict[str, PDB.Structure.Structure]:
    """
    Align structures based on MSA information.

    Args:
        msa_file: Path to FASTA file with MSA
        pdb_files: Dictionary mapping sequence IDs to PDB file paths
        output_dir: Directory to save aligned PDB files

    Returns:
        Dictionary of aligned structures
    """
    # Create output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        logger.info(f"Created output directory: {output_dir}")

    # Parse MSA
    sequences = parse_msa(msa_file)
    logger.info(f"Sequences in the MSA file: {len(sequences)}")
    for seq_id in sequences.keys():
        logger.debug(f"  • {seq_id}")

    logger.info(f"PDB files provided: {len(pdb_files)}")
    for pdb_id in pdb_files.keys():
        logger.debug(f"  • {pdb_id}")

    # Try to match IDs between MSA and PDB files
    structures = {}
    mappings = {}
    id_matches = {}

    # First try direct matches
    for seq_id, pdb_file in pdb_files.items():
        if seq_id in sequences:
            logger.info(f"Direct match found for {seq_id}")
            id_matches[seq_id] = seq_id
        else:
            # Try partial matches - check if PDB ID is contained within any MSA ID
            potential_matches = [
                msa_id for msa_id in sequences.keys() if seq_id in msa_id
            ]
            if potential_matches:
                # Use the first match (you might want to modify this logic)
                best_match = potential_matches[0]
                logger.info(
                    f"Partial match found: PDB ID {seq_id} matches MSA ID {best_match}"
                )
                id_matches[seq_id] = best_match
            # Also try if MSA ID is contained within PDB ID
            else:
                potential_matches = [
                    msa_id for msa_id in sequences.keys() if msa_id in seq_id
                ]
                if potential_matches:
                    # Use the first match
                    best_match = potential_matches[0]
                    logger.info(
                        f"Partial match found: MSA ID {best_match} matches PDB ID {seq_id}"
                    )
                    id_matches[seq_id] = best_match

    if not id_matches:
        logger.error("No matches found between PDB file IDs and MSA sequence IDs.")
        raise ValueError(
            "No matches found between PDB file IDs and MSA sequence IDs. Check that the IDs are consistent."
        )

    logger.info(f"Found {len(id_matches)} matches between PDB files and MSA sequences.")

    # Map sequence positions to structure positions for each protein
    for pdb_id, msa_id in id_matches.items():
        pdb_file = pdb_files[pdb_id]
        sequence = sequences[msa_id]
        try:
            mapping, structure = map_sequence_to_structure(sequence, pdb_file)
            mappings[pdb_id] = mapping
            structures[pdb_id] = structure
            logger.info(f"Successfully mapped {pdb_id} (using MSA sequence {msa_id})")
        except Exception as e:
            logger.error(f"Error mapping {pdb_id}: {str(e)}")

    if not structures:
        logger.error(
            "Could not map any structures. Check PDB files and MSA compatibility."
        )
        raise ValueError(
            "Could not map any structures. Check PDB files and MSA compatibility."
        )

    aligned_positions = get_aligned_positions(sequences)
    logger.info(
        f"Found {len(aligned_positions)} fully aligned positions across all sequences"
    )

    # Get the reference structure (first one)
    ref_id = list(structures.keys())[0]
    ref_structure = structures[ref_id]
    logger.info(f"Using {ref_id} as reference structure")

    # Initialize superimposer
    sup = Superimposer()

    # Align each structure to the reference
    for struct_id, structure in structures.items():
        # Skip the reference structure
        if struct_id == ref_id:
            continue

        # Get CA atoms for aligned positions in both structures
        ref_atoms = []
        struct_atoms = []

        for pos in aligned_positions:
            # Check if the position exists in both mappings
            if pos in mappings[ref_id] and pos in mappings[struct_id]:
                ref_res_id = mappings[ref_id][pos]
                struct_res_id = mappings[struct_id][pos]

                try:
                    ref_ca = ref_structure[0]["A"][ref_res_id]["CA"]
                    struct_ca = structure[0]["A"][struct_res_id]["CA"]
                    ref_atoms.append(ref_ca)
                    struct_atoms.append(struct_ca)
                except KeyError:
                    # Skip if CA atom not found
                    continue

        if len(ref_atoms) < 3:
            logger.warning(f"Not enough aligned atoms for {struct_id}")
            continue

        logger.info(f"Aligning {struct_id} using {len(ref_atoms)} CA atoms")

        # Calculate RMSD for the alignment
        sup.set_atoms(ref_atoms, struct_atoms)
        sup.apply(structure.get_atoms())
        logger.info(f"RMSD for {struct_id}: {sup.rms:.2f} Å")

        # Save aligned structure
        io = PDB.PDBIO()
        io.set_structure(structure)
        output_path = f"{output_dir}/{struct_id}_aligned.pdb"
        io.save(output_path)
        logger.info(f"Saved aligned structure to {output_path}")

    # Also save reference structure
    io = PDB.PDBIO()
    io.set_structure(ref_structure)
    ref_output_path = f"{output_dir}/{ref_id}_reference.pdb"
    io.save(ref_output_path)
    logger.info(f"Saved reference structure to {ref_output_path}")

    return structures


@click.command(
    context_settings={"show_default": True, "help_option_names": ["-h", "--help"]}
)
@click.argument("msa_file", type=click.Path(exists=True))
@click.argument("pdb_files", type=click.Path(exists=True), nargs=-1, required=True)
@click.option(
    "--output-dir",
    "-o",
    default="aligned_pdbs",
    help="Directory to save aligned PDB files",
)
@click.option(
    "--log-level",
    "-l",
    type=click.Choice(
        ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"], case_sensitive=False
    ),
    default="INFO",
    help="Set the logging level",
)
@click.option(
    "--reference",
    "-r",
    help="Specify a PDB file to use as reference (must be in the input list)",
)
def main(msa_file, pdb_files, output_dir, log_level, reference):
    """
    MSA-guided structure superposition.

    This script aligns a series of PDB files based on the information contained within
    a multiple sequence alignment (MSA) provided in FASTA format. It extracts the
    correspondence between residues from the MSA and uses this information to guide
    the structural superposition.
    """
    # Configure logging
    logging.basicConfig(
        level=getattr(logging, log_level.upper()),
        format="%(message)s",
        datefmt="[%X]",
        handlers=[RichHandler()],
    )

    # Create dictionary of PDB files
    pdb_dict = {}
    for pdb_file in pdb_files:
        # Get the basename without extension as the key
        base_name = os.path.splitext(os.path.basename(pdb_file))[0]
        pdb_dict[base_name] = pdb_file

    logger.info(f"Starting structure alignment based on MSA: {msa_file}")
    logger.info(f"Output directory: {output_dir}")

    try:
        # If reference is specified, reorder the dictionary to put it first
        if reference and reference in pdb_dict:
            ref_base = os.path.splitext(os.path.basename(reference))[0]
            ref_path = pdb_dict.pop(ref_base)
            # Create a new ordered dictionary with reference first
            new_dict = {ref_base: ref_path}
            new_dict.update(pdb_dict)
            pdb_dict = new_dict
            logger.info(f"Using {ref_base} as reference structure")

        # Align structures
        structures = align_structures_by_msa(msa_file, pdb_dict, output_dir)
        logger.info(f"Successfully aligned {len(structures)} structures")
    except Exception as e:
        logger.error(f"Error during alignment: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()
